/*
Page 19/308
程序清单1-1 非线程安全的数值序列生成器
*/
@NotThreadSafe
public class UnsafeSequence{
	private int value;
	/**返回一个唯一的数值。*/
	public int getNext(){
		return value++;
	}
}
/*
对于value++操作每个线程需要：
1.将主存中的value读入线程独有的工作空间（高速缓存或者累加器）
2.工作空间中将拷贝的数据加1
3.将工作空间的新值写入主存

若果有线程A和线程B“同时调用getNext()方法”,
当操作到共享变量value时,以如下执行流运行：
1）线程A将value拷贝到工作空间,线程A的时间片结束。
2）线程B将value拷贝到工作空间,线程B的时间片结束。
3）线程A的工作空间中缓存的value副本更新,线程A的时间片结束。
4）线程B的工作空间中缓存的value副本更新,线程B的时间片结束。
5）线程A将工作空间中的value新值写入主存,线程A时间片结束。
6）线程B将工作空间中的value新值写入主存,线程B时间片结束。
最终结果就是线程A与线程B写入到主存中的值相同,后者覆盖前者,
两个线程调用同一个计数方法得到了相同的值。

书中注释：由于存在指令重排序的可能,实际情况可能更糟糕。
*/
--程序清单1-1中演示的这类常见的并发安全问题,称为竞态条件(Race Condition)

--通过给getNext方法加锁可以保证value++操作的三个步骤只会在同一个线程中完成,避免了多线程的竞态条件


=====================================================================================================

要编写线程安全的代码,其核心在于要对状态访问操作进行管理,特别是对共享(Shared)状态和可变(Mutable)状态的访问。

[非正式意义上来说???]对象的状态是指存储在状态变量(例如实例或静态域)中的数据。对象的状态可能包括其他依赖对象的域。

对象的状态中包含了任何可能影响其外部可见行为的数据。

/*
状态：就是指数据
状态变量：就是指用于存储数据的对象成员属性,或者类的静态变量
对象的状态：就是指对象的成员变量或者静态变量中,存储的数据的总称,
对象的数据中可能包括该对象使用到的其他对象中的数据,
例如HashMap的数据不仅存储在HashMap对象本身中,同时也可以说是存储在许多Map.Entry对象中。

目前理解：
对象数据包含关系,不是说存储的数据量或者位置不同,仅仅是看待的角度不同。
而Map.Entry对象在外部被使用时,改变数据时也是对HashMap对象的数据的改变。

共享---变量中存储的数据可以被多个线程读取
可变---变量中存储的数据可以被多个线程修改

一个对象是否线程安全,取决于对象被多个线程访问的方式。
要使对象线程安全,需要采用同步机制来协同对对象数据的读取操作和写入操作

当多个线程读取某个用于存储数据的变量,并且有一个线程执行写入操作时,必须采用同步机制来协同这些线程对变量的读取。
*/




